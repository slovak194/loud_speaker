/*
 * File: get_ekf.c
 *
 * MATLAB Coder version            : 3.4
 * C/C++ source code generated on  : 28-Jul-2018 22:50:20
 */

/* Include Files */
#include "get_ekf.h"

/* Variable Definitions */
static float X[5];
static boolean_T X_not_empty;
static float P[25];
static float ut;

/* Function Declarations */
static void get_prediction(const float b_X[5], float u, const float n[5], const
  float p[2], float dt, float X_out[5], float J_X_out_x[25], float J_X_out_u[5],
  double J_X_out_n[25]);
static void get_prediction_init(void);

/* Function Definitions */

/*
 * Arguments    : const float b_X[5]
 *                float u
 *                const float n[5]
 *                const float p[2]
 *                float dt
 *                float X_out[5]
 *                float J_X_out_x[25]
 *                float J_X_out_u[5]
 *                double J_X_out_n[25]
 * Return Type  : void
 */
static void get_prediction(const float b_X[5], float u, const float n[5], const
  float p[2], float dt, float X_out[5], float J_X_out_x[25], float J_X_out_u[5],
  double J_X_out_n[25])
{
  static const double dv0[25] = { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    1.0 };

  float unusedU0[5];
  float b_ut;
  float b_dt[25];
  int i2;
  int i3;
  memcpy(&J_X_out_n[0], &dv0[0], 25U * sizeof(double));
  get_model_step(b_X, u, ut, n, p, dt, X_out, unusedU0, &b_ut);
  ut = b_ut;

  /* GET_PREDICTION_JACOBIANS */
  /*     [J_X_OUT_X,J_X_OUT_U,J_X_OUT_N] = GET_PREDICTION_JACOBIANS(IN1,V,IN3,IN4,DT) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     28-Jul-2018 15:05:17 */
  b_dt[0] = dt * ((-(dt * ((-b_X[3] + b_X[3] * b_X[2] * dt * 0.5F / p[1]) + p[0]
    * p[0] * b_X[3] * dt * 0.5F / (p[1] * b_X[4]))) / p[1] + b_X[3] * dt / p[1])
                  + dt * ((-b_X[3] * (b_X[3] * (dt * dt) * 0.25F / p[1] - 1.0F)
    + b_X[2] * dt * ((-b_X[3] + b_X[3] * b_X[2] * dt * 0.5F / p[1]) + p[0] * p[0]
                     * b_X[3] * dt * 0.5F / (p[1] * b_X[4])) * 0.5F / p[1]) + p
    [0] * p[0] * dt * ((-b_X[3] + b_X[3] * b_X[2] * dt * 0.5F / p[1]) + p[0] *
                       p[0] * b_X[3] * dt * 0.5F / (p[1] * b_X[4])) * 0.5F / (p
    [1] * b_X[4])) / p[1]) * -0.166666672F + 1.0F;
  b_dt[1] = dt * (((((b_X[3] * -2.0F + b_X[3] * b_X[2] * dt / p[1]) + p[0] * p[0]
                     * b_X[3] * dt / (p[1] * b_X[4])) / p[1] - b_X[3] / p[1]) -
                   ((b_X[3] * (b_X[3] * (dt * dt) * 0.25F / p[1] - 1.0F) * -2.0F
                     + b_X[2] * dt * ((-b_X[3] + b_X[3] * b_X[2] * dt * 0.5F /
    p[1]) + p[0] * p[0] * b_X[3] * dt * 0.5F / (p[1] * b_X[4])) / p[1]) + p[0] *
                    p[0] * dt * ((-b_X[3] + b_X[3] * b_X[2] * dt * 0.5F / p[1])
    + p[0] * p[0] * b_X[3] * dt * 0.5F / (p[1] * b_X[4])) / (p[1] * b_X[4])) /
                   p[1]) + ((-b_X[3] * (dt * dt * ((-b_X[3] + b_X[3] * b_X[2] *
    dt * 0.5F / p[1]) + p[0] * p[0] * b_X[3] * dt * 0.5F / (p[1] * b_X[4])) *
    0.5F / p[1] + 1.0F) + b_X[2] * dt * ((-b_X[3] * (b_X[3] * (dt * dt) * 0.25F /
    p[1] - 1.0F) + b_X[2] * dt * ((-b_X[3] + b_X[3] * b_X[2] * dt * 0.5F / p[1])
    + p[0] * p[0] * b_X[3] * dt * 0.5F / (p[1] * b_X[4])) * 0.5F / p[1]) + p[0] *
    p[0] * dt * ((-b_X[3] + b_X[3] * b_X[2] * dt * 0.5F / p[1]) + p[0] * p[0] *
                 b_X[3] * dt * 0.5F / (p[1] * b_X[4])) * 0.5F / (p[1] * b_X[4]))
    / p[1]) + p[0] * p[0] * dt * ((-b_X[3] * (b_X[3] * (dt * dt) * 0.25F / p[1]
    - 1.0F) + b_X[2] * dt * ((-b_X[3] + b_X[3] * b_X[2] * dt * 0.5F / p[1]) + p
    [0] * p[0] * b_X[3] * dt * 0.5F / (p[1] * b_X[4])) * 0.5F / p[1]) + p[0] *
    p[0] * dt * ((-b_X[3] + b_X[3] * b_X[2] * dt * 0.5F / p[1]) + p[0] * p[0] *
                 b_X[3] * dt * 0.5F / (p[1] * b_X[4])) * 0.5F / (p[1] * b_X[4]))
    / (p[1] * b_X[4])) / p[1]) * 0.166666672F;
  b_dt[2] = 0.0F;
  b_dt[3] = 0.0F;
  b_dt[4] = 0.0F;
  b_dt[5] = dt * (((dt * ((b_X[2] * (dt * ((b_X[3] * dt * -0.5F + b_X[2] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0] * p[0] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4]) * 0.5F / p[1]
    + 1.0F) - b_X[3] * dt * (dt * (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1]
    - 1.0F) * 0.5F) + p[0] * p[0] * (dt * ((b_X[3] * dt * -0.5F + b_X[2] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0] * p[0] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4]) * 0.5F / p[1]
    + 1.0F) / b_X[4]) / p[1] - dt * ((b_X[3] * dt * -0.5F + b_X[2] * (dt * (b_X
    [2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0] * p[0] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4]) / p[1]) + dt
                   * (b_X[2] + p[0] * p[0] / b_X[4]) / p[1]) - 6.0F) *
    -0.166666672F;
  b_dt[6] = dt * (((((b_X[2] * (dt * ((b_X[3] * dt * -0.5F + b_X[2] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0] * p[0] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4]) * 0.5F / p[1]
    + 1.0F) * 2.0F - b_X[3] * dt * (dt * (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F /
    p[1] - 1.0F)) + p[0] * p[0] * (dt * ((b_X[3] * dt * -0.5F + b_X[2] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0] * p[0] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4]) * 0.5F / p[1]
    + 1.0F) * 2.0F / b_X[4]) / p[1] - ((-b_X[3] * dt + b_X[2] * (dt * (b_X[2] +
    p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) * 2.0F) + p[0] * p[0] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) * 2.0F / b_X[4]) / p[1])
                   + (b_X[2] + p[0] * p[0] / b_X[4]) / p[1]) - ((b_X[2] * (dt *
    ((b_X[2] * (dt * ((b_X[3] * dt * -0.5F + b_X[2] * (dt * (b_X[2] + p[0] * p[0]
    / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0] * p[0] * (dt * (b_X[2] + p[0] * p[0]
    / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4]) * 0.5F / p[1] + 1.0F) - b_X[3] *
      dt * (dt * (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) * 0.5F) +
     p[0] * p[0] * (dt * ((b_X[3] * dt * -0.5F + b_X[2] * (dt * (b_X[2] + p[0] *
    p[0] / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0] * p[0] * (dt * (b_X[2] + p[0] *
    p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4]) * 0.5F / p[1] + 1.0F) / b_X[4])
    / p[1] - 1.0F) - b_X[3] * dt * (dt * ((b_X[3] * dt * -0.5F + b_X[2] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0] * p[0] * (dt *
    (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4]) * 0.5F / p[1]
    + 1.0F)) + p[0] * p[0] * (dt * ((b_X[2] * (dt * ((b_X[3] * dt * -0.5F + b_X
    [2] * (dt * (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0] *
    p[0] * (dt * (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4])
    * 0.5F / p[1] + 1.0F) - b_X[3] * dt * (dt * (b_X[2] + p[0] * p[0] / b_X[4]) *
    0.5F / p[1] - 1.0F) * 0.5F) + p[0] * p[0] * (dt * ((b_X[3] * dt * -0.5F +
    b_X[2] * (dt * (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F)) + p[0]
    * p[0] * (dt * (b_X[2] + p[0] * p[0] / b_X[4]) * 0.5F / p[1] - 1.0F) / b_X[4])
    * 0.5F / p[1] + 1.0F) / b_X[4]) / p[1] - 1.0F) / b_X[4]) / p[1]) *
    -0.166666672F + 1.0F;
  b_dt[7] = 0.0F;
  b_dt[8] = 0.0F;
  b_dt[9] = 0.0F;
  b_dt[10] = dt * ((-(dt * (((-b_X[1] + dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1])
    + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) + b_X[2] * dt * b_X[1] *
    0.5F / p[1]) + p[0] * p[0] * dt * b_X[1] * 0.5F / (p[1] * b_X[4]))) / p[1] +
                    dt * ((((b_X[1] - dt * ((b_X[3] * (b_X[0] + dt * b_X[1] *
    0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] *
    p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) + p[0] * p[0] * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) / b_X[4]) * 0.5F / p[1]) - b_X[3] * (dt * dt) * b_X[1] * 0.25F / p[1])
    + b_X[2] * dt * (((-b_X[1] + dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0]
    * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) + b_X[2] * dt * b_X[1] * 0.5F / p[1])
                     + p[0] * p[0] * dt * b_X[1] * 0.5F / (p[1] * b_X[4])) *
    0.5F / p[1]) + p[0] * p[0] * dt * (((-b_X[1] + dt * ((b_X[3] * b_X[0] + b_X
    [2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) + b_X[2] * dt *
    b_X[1] * 0.5F / p[1]) + p[0] * p[0] * dt * b_X[1] * 0.5F / (p[1] * b_X[4])) *
    0.5F / (p[1] * b_X[4])) / p[1]) + dt * b_X[1] / p[1]) * -0.166666672F;
  b_dt[11] = dt * ((((((b_X[1] * -2.0F + dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1])
    + p[0] * p[0] * b_X[1] / b_X[4]) / p[1]) + b_X[2] * dt * b_X[1] / p[1]) + p
                      [0] * p[0] * dt * b_X[1] / (p[1] * b_X[4])) / p[1] -
                     ((((b_X[1] * 2.0F - dt * ((b_X[3] * (b_X[0] + dt * b_X[1] *
    0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] *
    p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) + p[0] * p[0] * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) / b_X[4]) / p[1]) - b_X[3] * (dt * dt) * b_X[1] * 0.5F / p[1]) +
                       b_X[2] * dt * (((-b_X[1] + dt * ((b_X[3] * b_X[0] + b_X[2]
    * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) + b_X[2] * dt *
    b_X[1] * 0.5F / p[1]) + p[0] * p[0] * dt * b_X[1] * 0.5F / (p[1] * b_X[4])) /
                       p[1]) + p[0] * p[0] * dt * (((-b_X[1] + dt * ((b_X[3] *
    b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) +
    b_X[2] * dt * b_X[1] * 0.5F / p[1]) + p[0] * p[0] * dt * b_X[1] * 0.5F / (p
    [1] * b_X[4])) / (p[1] * b_X[4])) / p[1]) - b_X[1] / p[1]) + ((((-b_X[1] +
    dt * ((b_X[3] * (b_X[0] + dt * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] *
    b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) * 0.5F) + b_X[2] *
           (b_X[1] - dt * ((b_X[3] * (b_X[0] + dt * b_X[1] * 0.5F) + b_X[2] *
    (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] /
                    b_X[4]) * 0.5F / p[1])) + p[0] * p[0] * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) / b_X[4]) * 0.5F / p[1])) + p[0] * p[0] * (b_X[1] - dt * ((b_X[3] *
    (b_X[0] + dt * b_X[1] * 0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * b_X[0] +
    b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) + p[0] *
    p[0] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] *
    b_X[1] / b_X[4]) * 0.5F / p[1]) / b_X[4]) * 0.5F / p[1]) / b_X[4]) / p[1]) -
    b_X[3] * (dt * dt) * (((-b_X[1] + dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1])
    + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) + b_X[2] * dt * b_X[1] *
    0.5F / p[1]) + p[0] * p[0] * dt * b_X[1] * 0.5F / (p[1] * b_X[4])) * 0.5F /
    p[1]) + b_X[2] * dt * ((((b_X[1] - dt * ((b_X[3] * (b_X[0] + dt * b_X[1] *
    0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] *
    p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) + p[0] * p[0] * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) / b_X[4]) * 0.5F / p[1]) - b_X[3] * (dt * dt) * b_X[1] * 0.25F / p[1])
    + b_X[2] * dt * (((-b_X[1] + dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0]
    * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) + b_X[2] * dt * b_X[1] * 0.5F / p[1])
                     + p[0] * p[0] * dt * b_X[1] * 0.5F / (p[1] * b_X[4])) *
    0.5F / p[1]) + p[0] * p[0] * dt * (((-b_X[1] + dt * ((b_X[3] * b_X[0] + b_X
    [2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) + b_X[2] * dt *
    b_X[1] * 0.5F / p[1]) + p[0] * p[0] * dt * b_X[1] * 0.5F / (p[1] * b_X[4])) *
    0.5F / (p[1] * b_X[4])) / p[1]) + p[0] * p[0] * dt * ((((b_X[1] - dt *
    ((b_X[3] * (b_X[0] + dt * b_X[1] * 0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] *
    b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) +
     p[0] * p[0] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] *
    p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) / b_X[4]) * 0.5F / p[1]) - b_X[3] *
    (dt * dt) * b_X[1] * 0.25F / p[1]) + b_X[2] * dt * (((-b_X[1] + dt * ((b_X[3]
    * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])
    + b_X[2] * dt * b_X[1] * 0.5F / p[1]) + p[0] * p[0] * dt * b_X[1] * 0.5F /
    (p[1] * b_X[4])) * 0.5F / p[1]) + p[0] * p[0] * dt * (((-b_X[1] + dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) + b_X[2] * dt * b_X[1] * 0.5F / p[1]) + p[0] * p[0] * dt * b_X[1] *
    0.5F / (p[1] * b_X[4])) * 0.5F / (p[1] * b_X[4])) / (p[1] * b_X[4])) / p[1])
    * 0.166666672F;
  b_dt[12] = 1.0F;
  b_dt[13] = 0.0F;
  b_dt[14] = 0.0F;
  b_dt[15] = dt * ((-(dt * ((((-b_X[0] - dt * (b_X[1] - dt * ((b_X[3] * b_X[0] +
    b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) * 0.5F) +
    b_X[2] * dt * (((b_X[0] + dt * b_X[1] * 0.5F) - b_X[2] * dt * b_X[0] * 0.5F /
                    p[1]) - p[0] * p[0] * dt * b_X[0] * 0.5F / (p[1] * b_X[4])) *
    0.5F / p[1]) + b_X[3] * (dt * dt) * b_X[0] * 0.25F / p[1]) + p[0] * p[0] *
    dt * (((b_X[0] + dt * b_X[1] * 0.5F) - b_X[2] * dt * b_X[0] * 0.5F / p[1]) -
          p[0] * p[0] * dt * b_X[0] * 0.5F / (p[1] * b_X[4])) * 0.5F / (p[1] *
    b_X[4]))) / p[1] + dt * b_X[0] / p[1]) + dt * (((b_X[0] + dt * b_X[1] * 0.5F)
    - b_X[2] * dt * b_X[0] * 0.5F / p[1]) - p[0] * p[0] * dt * b_X[0] * 0.5F /
    (p[1] * b_X[4])) / p[1]) * -0.166666672F;
  b_dt[16] = dt * (((((((b_X[0] * 2.0F + dt * (b_X[1] - dt * ((b_X[3] * b_X[0] +
    b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) - b_X[2] *
                        dt * (((b_X[0] + dt * b_X[1] * 0.5F) - b_X[2] * dt *
    b_X[0] * 0.5F / p[1]) - p[0] * p[0] * dt * b_X[0] * 0.5F / (p[1] * b_X[4])) /
                        p[1]) - b_X[3] * (dt * dt) * b_X[0] * 0.5F / p[1]) - p[0]
                      * p[0] * dt * (((b_X[0] + dt * b_X[1] * 0.5F) - b_X[2] *
    dt * b_X[0] * 0.5F / p[1]) - p[0] * p[0] * dt * b_X[0] * 0.5F / (p[1] * b_X
    [4])) / (p[1] * b_X[4])) / p[1] + ((((b_X[0] + dt * (b_X[1] - dt * ((b_X[3] *
    (b_X[0] + dt * b_X[1] * 0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * b_X[0] +
    b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) + p[0] *
    p[0] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] *
    b_X[1] / b_X[4]) * 0.5F / p[1]) / b_X[4]) * 0.5F / p[1])) + b_X[2] * dt *
    ((((-b_X[0] - dt * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0]
    * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) * 0.5F) + b_X[2] * dt * (((b_X[0] +
    dt * b_X[1] * 0.5F) - b_X[2] * dt * b_X[0] * 0.5F / p[1]) - p[0] * p[0] * dt
    * b_X[0] * 0.5F / (p[1] * b_X[4])) * 0.5F / p[1]) + b_X[3] * (dt * dt) *
      b_X[0] * 0.25F / p[1]) + p[0] * p[0] * dt * (((b_X[0] + dt * b_X[1] * 0.5F)
    - b_X[2] * dt * b_X[0] * 0.5F / p[1]) - p[0] * p[0] * dt * b_X[0] * 0.5F /
    (p[1] * b_X[4])) * 0.5F / (p[1] * b_X[4])) / p[1]) - b_X[3] * (dt * dt) *
    (((b_X[0] + dt * b_X[1] * 0.5F) - b_X[2] * dt * b_X[0] * 0.5F / p[1]) - p[0]
     * p[0] * dt * b_X[0] * 0.5F / (p[1] * b_X[4])) * 0.5F / p[1]) + p[0] * p[0]
    * dt * ((((-b_X[0] - dt * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1])
    + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) * 0.5F) + b_X[2] * dt *
              (((b_X[0] + dt * b_X[1] * 0.5F) - b_X[2] * dt * b_X[0] * 0.5F / p
                [1]) - p[0] * p[0] * dt * b_X[0] * 0.5F / (p[1] * b_X[4])) *
              0.5F / p[1]) + b_X[3] * (dt * dt) * b_X[0] * 0.25F / p[1]) + p[0] *
            p[0] * dt * (((b_X[0] + dt * b_X[1] * 0.5F) - b_X[2] * dt * b_X[0] *
    0.5F / p[1]) - p[0] * p[0] * dt * b_X[0] * 0.5F / (p[1] * b_X[4])) * 0.5F /
            (p[1] * b_X[4])) / (p[1] * b_X[4])) / p[1]) + b_X[0] / p[1]) +
                   (((b_X[0] * 2.0F + dt * b_X[1]) - b_X[2] * dt * b_X[0] / p[1])
                    - p[0] * p[0] * dt * b_X[0] / (p[1] * b_X[4])) / p[1]) *
    -0.166666672F;
  b_dt[17] = 0.0F;
  b_dt[18] = 1.0F;
  b_dt[19] = 0.0F;
  b_dt[20] = dt * ((-(dt * ((-(p[0] * p[0]) / (b_X[4] * b_X[4]) * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) + (float)pow(p[0], 4.0) / (float)pow(b_X[4], 3.0) * dt * b_X[1] *
    0.5F / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4]) * b_X[2] * dt * b_X[1] * 0.5F
    / p[1])) / p[1] + dt * (((p[0] * p[0] / (b_X[4] * b_X[4]) * (b_X[1] - dt *
    ((b_X[3] * (b_X[0] + dt * b_X[1] * 0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] *
    b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) +
     p[0] * p[0] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] *
    p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) / b_X[4]) * 0.5F / p[1]) + b_X[2] *
    dt * ((-(p[0] * p[0]) / (b_X[4] * b_X[4]) * (b_X[1] - dt * ((b_X[3] * b_X[0]
    + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) + (float)
           pow(p[0], 4.0) / (float)pow(b_X[4], 3.0) * dt * b_X[1] * 0.5F / p[1])
          + p[0] * p[0] / (b_X[4] * b_X[4]) * b_X[2] * dt * b_X[1] * 0.5F / p[1])
    * 0.5F / p[1]) + p[0] * p[0] * dt * ((-(p[0] * p[0]) / (b_X[4] * b_X[4]) *
    (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] /
                    b_X[4]) * 0.5F / p[1]) + (float)pow(p[0], 4.0) / (float)pow
    (b_X[4], 3.0) * dt * b_X[1] * 0.5F / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4])
    * b_X[2] * dt * b_X[1] * 0.5F / p[1]) * 0.5F / (p[1] * b_X[4])) - p[0] * p[0]
    * b_X[3] / (b_X[4] * b_X[4]) * (dt * dt) * b_X[1] * 0.25F / p[1]) / p[1]) +
                   p[0] * p[0] / (b_X[4] * b_X[4]) * dt * b_X[1] / p[1]) *
    0.166666672F;
  b_dt[21] = dt * (((((p[0] * p[0] / (b_X[4] * b_X[4]) * (b_X[1] - dt * ((b_X[3]
    * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) *
                       -2.0F + (float)pow(p[0], 4.0) / (float)pow(b_X[4], 3.0) *
                       dt * b_X[1] / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4]) *
                      b_X[2] * dt * b_X[1] / p[1]) / p[1] + (((p[0] / (b_X[4] *
    b_X[4]) * (u - p[0] * (b_X[1] - dt * ((b_X[3] * (b_X[0] + dt * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) * 0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * (b_X[0] + dt * b_X[1] *
    0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] *
    p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) + p[0] * p[0] * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) / b_X[4]) * 0.5F / p[1])) + p[0] * p[0] * (b_X[1] - dt * ((b_X[3] *
    (b_X[0] + dt * b_X[1] * 0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * b_X[0] +
    b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) + p[0] *
    p[0] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] *
    b_X[1] / b_X[4]) * 0.5F / p[1]) / b_X[4]) * 0.5F / p[1]) / b_X[4]) / p[1]))
    - b_X[3] * (dt * dt) * ((-(p[0] * p[0]) / (b_X[4] * b_X[4]) * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) + (float)pow(p[0], 4.0) / (float)pow(b_X[4], 3.0) * dt * b_X[1] *
    0.5F / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4]) * b_X[2] * dt * b_X[1] * 0.5F
    / p[1]) * 0.5F / p[1]) + b_X[2] * dt * (((p[0] * p[0] / (b_X[4] * b_X[4]) *
    (b_X[1] - dt * ((b_X[3] * (b_X[0] + dt * b_X[1] * 0.5F) + b_X[2] * (b_X[1] -
    dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) *
    0.5F / p[1])) + p[0] * p[0] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] *
    b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1]) / b_X[4]) * 0.5F /
     p[1]) + b_X[2] * dt * ((-(p[0] * p[0]) / (b_X[4] * b_X[4]) * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) + (float)pow(p[0], 4.0) / (float)pow(b_X[4], 3.0) * dt * b_X[1] *
    0.5F / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4]) * b_X[2] * dt * b_X[1] * 0.5F
    / p[1]) * 0.5F / p[1]) + p[0] * p[0] * dt * ((-(p[0] * p[0]) / (b_X[4] *
    b_X[4]) * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] *
    b_X[1] / b_X[4]) * 0.5F / p[1]) + (float)pow(p[0], 4.0) / (float)pow(b_X[4],
    3.0) * dt * b_X[1] * 0.5F / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4]) * b_X[2]
    * dt * b_X[1] * 0.5F / p[1]) * 0.5F / (p[1] * b_X[4])) - p[0] * p[0] * b_X[3]
    / (b_X[4] * b_X[4]) * (dt * dt) * b_X[1] * 0.25F / p[1]) / p[1]) + p[0] * p
    [0] * dt * (((p[0] * p[0] / (b_X[4] * b_X[4]) * (b_X[1] - dt * ((b_X[3] *
    (b_X[0] + dt * b_X[1] * 0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * b_X[0] +
    b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) + p[0] *
    p[0] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] *
    b_X[1] / b_X[4]) * 0.5F / p[1]) / b_X[4]) * 0.5F / p[1]) + b_X[2] * dt *
                  ((-(p[0] * p[0]) / (b_X[4] * b_X[4]) * (b_X[1] - dt * ((b_X[3]
    * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])
                    + (float)pow(p[0], 4.0) / (float)pow(b_X[4], 3.0) * dt *
                    b_X[1] * 0.5F / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4]) *
                   b_X[2] * dt * b_X[1] * 0.5F / p[1]) * 0.5F / p[1]) + p[0] *
                 p[0] * dt * ((-(p[0] * p[0]) / (b_X[4] * b_X[4]) * (b_X[1] - dt
    * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) *
    0.5F / p[1]) + (float)pow(p[0], 4.0) / (float)pow(b_X[4], 3.0) * dt * b_X[1]
    * 0.5F / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4]) * b_X[2] * dt * b_X[1] *
    0.5F / p[1]) * 0.5F / (p[1] * b_X[4])) - p[0] * p[0] * b_X[3] / (b_X[4] *
    b_X[4]) * (dt * dt) * b_X[1] * 0.25F / p[1]) / (p[1] * b_X[4])) / p[1]) -
                    (((p[0] * p[0] / (b_X[4] * b_X[4]) * (b_X[1] - dt * ((b_X[3]
    * (b_X[0] + dt * b_X[1] * 0.5F) + b_X[2] * (b_X[1] - dt * ((b_X[3] * b_X[0]
    + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F / p[1])) + p[0] *
    p[0] * (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] *
    b_X[1] / b_X[4]) * 0.5F / p[1]) / b_X[4]) * 0.5F / p[1]) * 2.0F + b_X[2] *
                       dt * ((-(p[0] * p[0]) / (b_X[4] * b_X[4]) * (b_X[1] - dt *
    ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] / b_X[4]) * 0.5F
    / p[1]) + (float)pow(p[0], 4.0) / (float)pow(b_X[4], 3.0) * dt * b_X[1] *
    0.5F / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4]) * b_X[2] * dt * b_X[1] * 0.5F
    / p[1]) / p[1]) + p[0] * p[0] * dt * ((-(p[0] * p[0]) / (b_X[4] * b_X[4]) *
    (b_X[1] - dt * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + p[0] * p[0] * b_X[1] /
                    b_X[4]) * 0.5F / p[1]) + (float)pow(p[0], 4.0) / (float)pow
    (b_X[4], 3.0) * dt * b_X[1] * 0.5F / p[1]) + p[0] * p[0] / (b_X[4] * b_X[4])
    * b_X[2] * dt * b_X[1] * 0.5F / p[1]) / (p[1] * b_X[4])) - p[0] * p[0] *
                     b_X[3] / (b_X[4] * b_X[4]) * (dt * dt) * b_X[1] * 0.5F / p
                     [1]) / p[1]) - p[0] * p[0] / (b_X[4] * b_X[4]) * b_X[1] /
                   p[1]) * -0.166666672F;
  b_dt[22] = 0.0F;
  b_dt[23] = 0.0F;
  b_dt[24] = 1.0F;
  for (i2 = 0; i2 < 5; i2++) {
    for (i3 = 0; i3 < 5; i3++) {
      J_X_out_x[i3 + 5 * i2] = b_dt[i3 + 5 * i2];
    }
  }

  J_X_out_u[0] = 0.0F;
  J_X_out_u[1] = p[0] * dt * 0.166666672F / (p[1] * b_X[4]);
  J_X_out_u[2] = 0.0F;
  J_X_out_u[3] = 0.0F;
  J_X_out_u[4] = 0.0F;
}

/*
 * Arguments    : void
 * Return Type  : void
 */
static void get_prediction_init(void)
{
  ut = 0.0F;
}

/*
 * Arguments    : ctrl_t *out
 * Return Type  : void
 */
void ctrl_struct_initializer(ctrl_t *out)
{
  out->v = 0.0F;
}

/*
 * Arguments    : dstate_t *out
 * Return Type  : void
 */
void dstate_struct_initializer(dstate_t *out)
{
  out->xd_dot = 0.0F;
  out->xd_dot_dot = 0.0F;
  out->R_m_dot = 0.009F;
  out->K_m_dot = 41.75F;
  out->R_e_dot = 31.75F;
}

/*
 * Arguments    : struct0_T *out
 * Return Type  : void
 */
void filter_parameters_struct_initializer(struct0_T *out)
{
  static struct0_T r0 = { { 0.001F, 1.0F, 0.011F, 39.75F, 29.75F },/* X0 */
    { 100000.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 100000.0F, 0.0F, 0.0F, 0.0F, 0.0F,
      0.0F, 100000.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 100000.0F, 0.0F, 0.0F, 0.0F,
      0.0F, 0.0F, 100000.0F },         /* P0 */
    { 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
      1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
      1.0F },                          /* Q */
    1.0F,                              /* U */
    { 1.0E-5F, 10.0F }                 /* R */
  };

  *out = r0;
}

/*
 * GET_R_E_MEASUREMENT
 *     [Y_R_E,J_Y_X,J_Y_U,J_Y_N] = GET_R_E_MEASUREMENT(IN1,V,IN3,IN4)
 * Arguments    : const float b_X[5]
 *                float v
 *                const float n[5]
 *                const float p[2]
 *                float *y_R_e
 *                double J_y_x[5]
 *                double *J_y_u
 *                double J_y_n[5]
 * Return Type  : void
 */
void get_R_e_measurement(const float b_X[5], float v, const float n[5], const
  float p[2], float *y_R_e, double J_y_x[5], double *J_y_u, double J_y_n[5])
{
  int i4;
  static const signed char iv3[5] = { 0, 0, 0, 0, 1 };

  (void)v;
  (void)n;
  (void)p;

  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     28-Jul-2018 15:05:18 */
  *y_R_e = b_X[4];
  *J_y_u = 0.0;
  for (i4 = 0; i4 < 5; i4++) {
    J_y_x[i4] = iv3[i4];
    J_y_n[i4] = 0.0;
  }
}

/*
 * coder.cstructname(f_p ,'filter_parameters_t');
 * Arguments    : float u
 *                const float y[2]
 *                const struct0_T *f_p
 *                const float p[2]
 *                float dt
 *                float X_out[5]
 *                float P_diag[5]
 * Return Type  : void
 */
void get_ekf(float u, const float y[2], const struct0_T *f_p, const float p[2],
             float dt, float X_out[5], float P_diag[5])
{
  int i;
  int MahDistSquaredMax[4];
  static const short iv0[4] = { 500, 5, 5, 500 };

  float J_u[5];
  float b_X[5];
  float J_x[25];
  float b_J_u[5];
  double J_n[25];
  int i0;
  float b_J_x[25];
  float b_J_n[25];
  float c_J_x[25];
  float c_J_n[25];
  int i1;
  float z;
  float f0;
  float Zinv;
  float K[5];
  static const signed char iv1[5] = { 0, 0, 0, 0, 1 };

  static const signed char iv2[5] = { 0, 0, 0, 0, 1 };

  if (!X_not_empty) {
    for (i = 0; i < 5; i++) {
      X[i] = f_p->X0[i];
    }

    X_not_empty = true;
    memcpy(&P[0], &f_p->P0[0], 25U * sizeof(float));

    /*  State vector covariance */
  }

  for (i = 0; i < 4; i++) {
    MahDistSquaredMax[i] = iv0[i] * iv0[i];
  }

  /*  TODO move to params. */
  /*  We are not going to feed noize inside filter :) */
  /*  Evolution step */
  for (i = 0; i < 5; i++) {
    J_u[i] = 0.0F;
  }

  get_prediction(X, u, J_u, p, dt, b_X, J_x, b_J_u, J_n);
  for (i = 0; i < 5; i++) {
    for (i0 = 0; i0 < 5; i0++) {
      b_J_x[i + 5 * i0] = 0.0F;
      b_J_n[i + 5 * i0] = 0.0F;
      for (i1 = 0; i1 < 5; i1++) {
        b_J_x[i + 5 * i0] += J_x[i + 5 * i1] * P[i1 + 5 * i0];
        b_J_n[i + 5 * i0] += (float)J_n[i + 5 * i1] * f_p->Q[i1 + 5 * i0];
      }
    }

    for (i0 = 0; i0 < 5; i0++) {
      c_J_x[i + 5 * i0] = 0.0F;
      c_J_n[i + 5 * i0] = 0.0F;
      for (i1 = 0; i1 < 5; i1++) {
        c_J_x[i + 5 * i0] += b_J_x[i + 5 * i1] * J_x[i0 + 5 * i1];
        c_J_n[i + 5 * i0] += b_J_n[i + 5 * i1] * (float)J_n[i0 + 5 * i1];
      }
    }
  }

  for (i = 0; i < 5; i++) {
    for (i0 = 0; i0 < 5; i0++) {
      P[i + 5 * i0] = (c_J_x[i + 5 * i0] + c_J_n[i + 5 * i0]) + b_J_u[i] *
        f_p->U * b_J_u[i0];
    }
  }

  for (i = 0; i < 5; i++) {
    for (i0 = 0; i0 < 5; i0++) {
      J_x[i0 + 5 * i] = (P[i0 + 5 * i] + P[i + 5 * i0]) / 2.0F;
    }
  }

  /*  Ensure it is symetric. On target I would store it as a triangle. */
  /*  Get predicted measurements */
  /* GET_II_MEASUREMENT */
  /*     [Y_II,J_Y_X,J_Y_U,J_Y_N] = GET_II_MEASUREMENT(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     28-Jul-2018 15:05:18 */
  b_J_u[0] = 0.0F;
  b_J_u[1] = -p[0] / b_X[4];
  b_J_u[2] = 0.0F;
  b_J_u[3] = 0.0F;
  b_J_u[4] = -1.0F / (b_X[4] * b_X[4]) * (u - p[0] * b_X[1]);
  z = y[0] - (u - p[0] * b_X[1]) / b_X[4];
  f0 = 0.0F;
  for (i = 0; i < 5; i++) {
    J_u[i] = 0.0F;
    for (i0 = 0; i0 < 5; i0++) {
      P[i0 + 5 * i] = J_x[i0 + 5 * i];
      J_u[i] += b_J_u[i0] * P[i0 + 5 * i];
    }

    f0 += J_u[i] * b_J_u[i];
  }

  Zinv = 1.0F / (f0 + f_p->R[0]);
  if ((double)(z * Zinv * z) < MahDistSquaredMax[0]) {
    for (i = 0; i < 5; i++) {
      J_u[i] = 0.0F;
      for (i0 = 0; i0 < 5; i0++) {
        J_u[i] += P[i + 5 * i0] * b_J_u[i0];
      }

      K[i] = J_u[i] * Zinv;
      for (i0 = 0; i0 < 5; i0++) {
        b_J_x[i + 5 * i0] = K[i] * b_J_u[i0];
      }

      for (i0 = 0; i0 < 5; i0++) {
        f0 = 0.0F;
        for (i1 = 0; i1 < 5; i1++) {
          f0 += b_J_x[i + 5 * i1] * P[i1 + 5 * i0];
        }

        J_x[i + 5 * i0] = P[i + 5 * i0] - f0;
      }

      b_X[i] += K[i] * z;
    }

    for (i = 0; i < 5; i++) {
      for (i0 = 0; i0 < 5; i0++) {
        P[i0 + 5 * i] = J_x[i0 + 5 * i];
      }
    }
  }

  /*  Get predicted measurements */
  /* GET_R_E_MEASUREMENT */
  /*     [Y_R_E,J_Y_X,J_Y_U,J_Y_N] = GET_R_E_MEASUREMENT(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     28-Jul-2018 15:05:18 */
  z = y[1] - b_X[4];
  f0 = 0.0F;
  for (i = 0; i < 5; i++) {
    J_u[i] = 0.0F;
    for (i0 = 0; i0 < 5; i0++) {
      J_u[i] += (float)iv2[i0] * P[i0 + 5 * i];
    }

    f0 += J_u[i] * (float)iv1[i];
  }

  Zinv = 1.0F / (f0 + f_p->R[1]);
  if ((double)(z * Zinv * z) < MahDistSquaredMax[1]) {
    for (i = 0; i < 5; i++) {
      J_u[i] = 0.0F;
      for (i0 = 0; i0 < 5; i0++) {
        J_u[i] += P[i + 5 * i0] * (float)iv1[i0];
      }

      K[i] = J_u[i] * Zinv;
      for (i0 = 0; i0 < 5; i0++) {
        b_J_x[i + 5 * i0] = K[i] * (float)iv2[i0];
      }

      for (i0 = 0; i0 < 5; i0++) {
        f0 = 0.0F;
        for (i1 = 0; i1 < 5; i1++) {
          f0 += b_J_x[i + 5 * i1] * P[i1 + 5 * i0];
        }

        J_x[i + 5 * i0] = P[i + 5 * i0] - f0;
      }

      b_X[i] += K[i] * z;
    }

    for (i = 0; i < 5; i++) {
      for (i0 = 0; i0 < 5; i0++) {
        P[i0 + 5 * i] = J_x[i0 + 5 * i];
      }
    }
  }

  /*  Update filter state */
  for (i = 0; i < 5; i++) {
    X[i] = b_X[i];
    X_out[i] = X[i];
    P_diag[i] = P[i * 6];
  }
}

/*
 * Arguments    : void
 * Return Type  : void
 */
void get_ekf_initialize(void)
{
  X_not_empty = false;
  get_prediction_init();
}

/*
 * Arguments    : void
 * Return Type  : void
 */
void get_ekf_terminate(void)
{
  /* (no terminate code required) */
}

/*
 * GET_II_MEASUREMENT
 *     [Y_II,J_Y_X,J_Y_U,J_Y_N] = GET_II_MEASUREMENT(IN1,V,IN3,IN4)
 * Arguments    : const float b_X[5]
 *                float v
 *                const float n[5]
 *                const float p[2]
 *                float *y_ii
 *                float J_y_x[5]
 *                float *J_y_u
 *                double J_y_n[5]
 * Return Type  : void
 */
void get_ii_measurement(const float b_X[5], float v, const float n[5], const
  float p[2], float *y_ii, float J_y_x[5], float *J_y_u, double J_y_n[5])
{
  int i5;
  (void)n;

  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     28-Jul-2018 15:05:18 */
  *y_ii = (v - p[0] * b_X[1]) / b_X[4];
  J_y_x[0] = 0.0F;
  J_y_x[1] = -p[0] / b_X[4];
  J_y_x[2] = 0.0F;
  J_y_x[3] = 0.0F;
  J_y_x[4] = -1.0F / (b_X[4] * b_X[4]) * (v - p[0] * b_X[1]);
  *J_y_u = 1.0F / b_X[4];
  for (i5 = 0; i5 < 5; i5++) {
    J_y_n[i5] = 0.0;
  }
}

/*
 * Arguments    : const float b_X[5]
 *                float u
 *                float b_ut
 *                const float n[5]
 *                const float p[2]
 *                float dt
 *                float X_out[5]
 *                float dX[5]
 *                float *utt
 * Return Type  : void
 */
void get_model_step(const float b_X[5], float u, float b_ut, const float n[5],
                    const float p[2], float dt, float X_out[5], float dX[5],
                    float *utt)
{
  float k1[5];
  float y;
  int i;
  float c_X[5];
  float k2[5];
  float k3[5];

  /* GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL */
  /*     [DX,DEBUG] = GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     28-Jul-2018 15:05:17 */
  k1[0] = b_X[1];
  k1[1] = -((b_X[3] * b_X[0] + b_X[2] * b_X[1]) - p[0] * (b_ut - p[0] * b_X[1]) /
            b_X[4]) / p[1];
  k1[2] = 0.0F;
  k1[3] = 0.0F;
  k1[4] = 0.0F;
  y = dt / 2.0F;
  for (i = 0; i < 5; i++) {
    c_X[i] = b_X[i] + y * k1[i];
  }

  /* GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL */
  /*     [DX,DEBUG] = GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     28-Jul-2018 15:05:17 */
  k2[0] = c_X[1];
  k2[1] = -((c_X[3] * c_X[0] + c_X[2] * c_X[1]) - p[0] * (b_ut - p[0] * c_X[1]) /
            c_X[4]) / p[1];
  k2[2] = 0.0F;
  k2[3] = 0.0F;
  k2[4] = 0.0F;
  y = dt / 2.0F;
  for (i = 0; i < 5; i++) {
    c_X[i] = b_X[i] + y * k2[i];
  }

  /* GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL */
  /*     [DX,DEBUG] = GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     28-Jul-2018 15:05:17 */
  k3[0] = c_X[1];
  k3[1] = -((c_X[3] * c_X[0] + c_X[2] * c_X[1]) - p[0] * (b_ut - p[0] * c_X[1]) /
            c_X[4]) / p[1];
  k3[2] = 0.0F;
  k3[3] = 0.0F;
  k3[4] = 0.0F;
  for (i = 0; i < 5; i++) {
    c_X[i] = b_X[i] + dt * k3[i];
  }

  /* GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL */
  /*     [DX,DEBUG] = GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     28-Jul-2018 15:05:17 */
  y = dt / 6.0F;
  dX[0] = y * (((b_X[1] + 2.0F * k2[0]) + 2.0F * k3[0]) + c_X[1]);
  dX[1] = y * (((k1[1] + 2.0F * k2[1]) + 2.0F * k3[1]) + -((c_X[3] * c_X[0] +
    c_X[2] * c_X[1]) - p[0] * (u - p[0] * c_X[1]) / c_X[4]) / p[1]);
  dX[2] = 0.0F;
  dX[3] = 0.0F;
  dX[4] = 0.0F;
  for (i = 0; i < 5; i++) {
    X_out[i] = (b_X[i] + dX[i]) + n[i];
    dX[i] /= dt;
  }

  *utt = u;
}

/*
 * Arguments    : parameters_t *out
 * Return Type  : void
 */
void parameters_initializer(parameters_t *out)
{
  out->Bl = 0.23F;
  out->M_m = 8.0E-6F;
}

/*
 * Arguments    : char out[25]
 * Return Type  : void
 */
void state_names_initializer(char out[25])
{
  int i6;
  static const char cv0[25] = { 'x', 'd', ',', ' ', 'x', 'd', '_', 'd', 'o', 't',
    ',', ' ', 'R', '_', 'm', ',', ' ', 'K', '_', 'm', ',', ' ', 'R', '_', 'e' };

  for (i6 = 0; i6 < 25; i6++) {
    out[i6] = cv0[i6];
  }
}

/*
 * Arguments    : state_t *out
 * Return Type  : void
 */
void state_struct_initializer(state_t *out)
{
  out->xd = 0.0F;
  out->xd_dot = 0.0F;
  out->R_m = 0.009F;
  out->K_m = 41.75F;
  out->R_e = 31.75F;
}

/*
 * File trailer for get_ekf.c
 *
 * [EOF]
 */
