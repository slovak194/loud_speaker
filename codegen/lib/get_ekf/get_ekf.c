/*
 * File: get_ekf.c
 *
 * MATLAB Coder version            : 3.4
 * C/C++ source code generated on  : 30-Jul-2018 16:43:34
 */

/* Include Files */
#include "get_ekf.h"

/* Variable Definitions */
static float X[5];
static boolean_T X_not_empty;
static float P[25];
static float ut;

/* Function Declarations */
static void get_prediction(const float b_X[5], float u, const float n[5], const
  float p[2], float dt, float X_out[5], float J_X_out_x[25], float J_X_out_u[5],
  double J_X_out_n[25]);
static void get_prediction_init(void);

/* Function Definitions */

/*
 * Arguments    : const float b_X[5]
 *                float u
 *                const float n[5]
 *                const float p[2]
 *                float dt
 *                float X_out[5]
 *                float J_X_out_x[25]
 *                float J_X_out_u[5]
 *                double J_X_out_n[25]
 * Return Type  : void
 */
static void get_prediction(const float b_X[5], float u, const float n[5], const
  float p[2], float dt, float X_out[5], float J_X_out_x[25], float J_X_out_u[5],
  double J_X_out_n[25])
{
  static const double dv0[25] = { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    1.0 };

  float unusedU0[5];
  float t28;
  float t2;
  float t4;
  float t5;
  float t7;
  float t9;
  float t11;
  float t14;
  float t16;
  float t22;
  float t23;
  float t24;
  float t27;
  float t29;
  float t32;
  float t39;
  float t40;
  float t42;
  float t47;
  float t51;
  float t53;
  float t58;
  float t59;
  float t60;
  float t64;
  float t65;
  float b_dt[25];
  int i2;
  int i3;
  memcpy(&J_X_out_n[0], &dv0[0], 25U * sizeof(double));
  get_model_step(b_X, u, ut, n, p, dt, X_out, unusedU0, &t28);
  ut = t28;

  /* GET_PREDICTION_JACOBIANS */
  /*     [J_X_OUT_X,J_X_OUT_U,J_X_OUT_N] = GET_PREDICTION_JACOBIANS(IN1,V,IN3,IN4,DT) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     30-Jul-2018 16:43:27 */
  t2 = 1.0F / p[1];
  t4 = p[0] * p[0];
  t5 = 1.0F / b_X[4];
  t7 = (-b_X[3] + b_X[3] * b_X[2] * dt * t2 * 0.5F) + b_X[3] * dt * t2 * t4 * t5
    * 0.5F;
  t9 = b_X[2] + t4 * t5;
  t11 = dt * t2 * t9 * 0.5F - 1.0F;
  t14 = (b_X[2] * t11 + t4 * t5 * t11) - b_X[3] * dt * 0.5F;
  t16 = dt * t2 * t14 * 0.5F + 1.0F;
  t22 = dt * t2 * ((b_X[3] * b_X[0] + b_X[2] * b_X[1]) + t4 * t5 * b_X[1]) *
    0.5F;
  t23 = t22 - b_X[1];
  t24 = dt * dt;
  t27 = ((t22 + b_X[2] * dt * t2 * b_X[1] * 0.5F) + dt * t2 * t4 * t5 * b_X[1] *
         0.5F) - b_X[1];
  t28 = dt * b_X[1] * 0.5F;
  t29 = ((t28 - b_X[2] * dt * t2 * b_X[0] * 0.5F) - dt * t2 * t4 * t5 * b_X[0] *
         0.5F) + b_X[0];
  t32 = 1.0F / (b_X[4] * b_X[4]);
  t28 = dt * t2 * ((b_X[2] * t23 + t4 * t5 * t23) - b_X[3] * (t28 + b_X[0])) *
    0.5F;
  t39 = dt * t2 * (t4 * t4) * (1.0F / (float)pow(b_X[4], 3.0)) * b_X[1] * 0.5F;
  t40 = b_X[2] * dt * t2 * t4 * t32 * b_X[1] * 0.5F;
  t42 = (t39 + t40) + t4 * t32 * (t22 - b_X[1]);
  t47 = (b_X[2] * dt * t2 * t7 * 0.5F + dt * t2 * t4 * t5 * t7 * 0.5F) - b_X[3] *
    (b_X[3] * t2 * t24 * 0.25F - 1.0F);
  t51 = (b_X[2] * t16 + t4 * t5 * t16) - b_X[3] * dt * t11 * 0.5F;
  t53 = dt * t2 * t51;
  t58 = (((t28 + b_X[2] * dt * t2 * t27 * 0.5F) + dt * t2 * t4 * t5 * t27 * 0.5F)
         - b_X[3] * t2 * t24 * b_X[1] * 0.25F) + b_X[1];
  t59 = dt * t23 * 0.5F;
  t60 = t28 + b_X[1];
  t28 = b_X[2] * dt * t2 * t29 * 0.5F;
  t11 = b_X[3] * t2 * t24 * b_X[0] * 0.25F;
  t64 = dt * t2 * t4 * t5 * t29 * 0.5F;
  t65 = (((t59 + t28) + t11) + t64) - b_X[0];
  t64 = (((t28 + t11) + t64) + dt * (t22 - b_X[1]) * 0.5F) - b_X[0];
  t28 = dt * t2 * ((b_X[2] * t60 + t4 * t5 * t60) - b_X[3] * (t59 - b_X[0]));
  t11 = ((t4 * t32 * t60 + b_X[2] * dt * t2 * t42 * 0.5F) + dt * t2 * t4 * t5 *
         t42 * 0.5F) - b_X[3] * t2 * t4 * t24 * t32 * b_X[1] * 0.25F;
  b_dt[0] = dt * ((b_X[3] * dt * t2 - dt * t2 * t7) + dt * t2 * t47) *
    -0.166666672F + 1.0F;
  b_dt[1] = dt * (((b_X[3] * t2 - t2 * t7 * 2.0F) + t2 * t47 * 2.0F) - t2 *
                  ((-b_X[3] * (t2 * t7 * t24 * 0.5F + 1.0F) + b_X[2] * dt * t2 *
                    t47) + dt * t2 * t4 * t5 * t47)) * -0.166666672F;
  b_dt[2] = 0.0F;
  b_dt[3] = 0.0F;
  b_dt[4] = 0.0F;
  b_dt[5] = dt * (((t53 + dt * t2 * t9) - dt * t2 * t14) - 6.0F) * -0.166666672F;
  b_dt[6] = dt * (((t2 * t9 - t2 * t14 * 2.0F) + t2 * t51 * 2.0F) - t2 * ((b_X[2]
    * (t53 - 1.0F) - b_X[3] * dt * t16) + t4 * t5 * (t53 - 1.0F))) *
    -0.166666672F + 1.0F;
  b_dt[7] = 0.0F;
  b_dt[8] = 0.0F;
  b_dt[9] = 0.0F;
  b_dt[10] = dt * ((-dt * t2 * t27 + dt * t2 * t58) + dt * t2 * b_X[1]) *
    -0.166666672F;
  b_dt[11] = dt * (((t2 * ((((t28 - b_X[1]) - b_X[3] * t2 * t24 * t27 * 0.5F) +
    b_X[2] * dt * t2 * t58) + dt * t2 * t4 * t5 * t58) + t2 * t27 * 2.0F) - t2 *
                    t58 * 2.0F) - t2 * b_X[1]) * 0.166666672F;
  b_dt[12] = 1.0F;
  b_dt[13] = 0.0F;
  b_dt[14] = 0.0F;
  b_dt[15] = dt * ((dt * t2 * t29 - dt * t2 * t65) + dt * t2 * b_X[0]) *
    -0.166666672F;
  b_dt[16] = dt * (((t2 * t29 * 2.0F - t2 * t65 * 2.0F) + t2 * b_X[0]) + t2 *
                   ((((b_X[0] + dt * t60) - b_X[3] * t2 * t24 * t29 * 0.5F) +
                     b_X[2] * dt * t2 * t64) + dt * t2 * t4 * t5 * t64)) *
    -0.166666672F;
  b_dt[17] = 0.0F;
  b_dt[18] = 1.0F;
  b_dt[19] = 0.0F;
  b_dt[20] = dt * ((-dt * t2 * ((t39 + t40) + t4 * t23 * t32) + dt * t2 * t11) +
                   dt * t2 * t4 * t32 * b_X[1]) * 0.166666672F;
  b_dt[21] = dt * (((t2 * (((p[0] * t32 * (u + p[0] * (t28 - b_X[1])) - b_X[3] *
    t2 * t24 * t42 * 0.5F) + b_X[2] * dt * t2 * t11) + dt * t2 * t4 * t5 * t11)
                     + t2 * t42 * 2.0F) - t2 * t11 * 2.0F) - t2 * t4 * t32 *
                   b_X[1]) * -0.166666672F;
  b_dt[22] = 0.0F;
  b_dt[23] = 0.0F;
  b_dt[24] = 1.0F;
  for (i2 = 0; i2 < 5; i2++) {
    for (i3 = 0; i3 < 5; i3++) {
      J_X_out_x[i3 + 5 * i2] = b_dt[i3 + 5 * i2];
    }
  }

  J_X_out_u[0] = 0.0F;
  J_X_out_u[1] = p[0] * dt * t2 * t5 * 0.166666672F;
  J_X_out_u[2] = 0.0F;
  J_X_out_u[3] = 0.0F;
  J_X_out_u[4] = 0.0F;
}

/*
 * Arguments    : void
 * Return Type  : void
 */
static void get_prediction_init(void)
{
  ut = 0.0F;
}

/*
 * Arguments    : ctrl_t *out
 * Return Type  : void
 */
void ctrl_struct_initializer(ctrl_t *out)
{
  out->v = 0.0F;
}

/*
 * Arguments    : dstate_t *out
 * Return Type  : void
 */
void dstate_struct_initializer(dstate_t *out)
{
  out->xd_dot = 0.0F;
  out->xd_dot_dot = 0.0F;
  out->R_m_dot = 0.009F;
  out->K_m_dot = 41.75F;
  out->R_e_dot = 31.75F;
}

/*
 * Arguments    : struct0_T *out
 * Return Type  : void
 */
void filter_parameters_struct_initializer(struct0_T *out)
{
  static struct0_T r0 = { { 0.001F, 1.0F, 0.011F, 39.75F, 29.75F },/* X0 */
    { 100000.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 100000.0F, 0.0F, 0.0F, 0.0F, 0.0F,
      0.0F, 100000.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 100000.0F, 0.0F, 0.0F, 0.0F,
      0.0F, 0.0F, 100000.0F },         /* P0 */
    { 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
      1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
      1.0F },                          /* Q */
    1.0F,                              /* U */
    { 1.0E-5F, 1000.0F }               /* R */
  };

  *out = r0;
}

/*
 * GET_R_E_MEASUREMENT
 *     [Y_R_E,J_Y_X,J_Y_U,J_Y_N] = GET_R_E_MEASUREMENT(IN1,V,IN3,IN4)
 * Arguments    : const float b_X[5]
 *                float v
 *                const float n[5]
 *                const float p[2]
 *                float *y_R_e
 *                double J_y_x[5]
 *                double *J_y_u
 *                double J_y_n[5]
 * Return Type  : void
 */
void get_R_e_measurement(const float b_X[5], float v, const float n[5], const
  float p[2], float *y_R_e, double J_y_x[5], double *J_y_u, double J_y_n[5])
{
  int i4;
  static const signed char iv2[5] = { 0, 0, 0, 0, 1 };

  (void)v;
  (void)n;
  (void)p;

  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     30-Jul-2018 16:43:28 */
  *y_R_e = b_X[4];
  *J_y_u = 0.0;
  for (i4 = 0; i4 < 5; i4++) {
    J_y_x[i4] = iv2[i4];
    J_y_n[i4] = 0.0;
  }
}

/*
 * Arguments    : float u
 *                const float y[2]
 *                const struct0_T *f_p
 *                const float p[2]
 *                float dt
 *                float X_out[5]
 *                float P_diag[5]
 * Return Type  : void
 */
void get_ekf(float u, const float y[2], const struct0_T *f_p, const float p[2],
             float dt, float X_out[5], float P_diag[5])
{
  int i;
  int MahDistSquaredMax[2];
  float J_u[5];
  float b_X[5];
  float J_x[25];
  float b_J_u[5];
  double J_n[25];
  int i0;
  float b_J_x[25];
  float b_J_n[25];
  float c_J_x[25];
  float c_J_n[25];
  int i1;
  float z;
  float f0;
  float Zinv;
  float K[5];
  static const signed char iv0[5] = { 0, 0, 0, 0, 1 };

  static const signed char iv1[5] = { 0, 0, 0, 0, 1 };

  if (!X_not_empty) {
    for (i = 0; i < 5; i++) {
      X[i] = f_p->X0[i];
    }

    X_not_empty = true;
    memcpy(&P[0], &f_p->P0[0], 25U * sizeof(float));

    /*  State vector covariance */
  }

  for (i = 0; i < 2; i++) {
    MahDistSquaredMax[i] = (500 + -495 * i) * (500 + -495 * i);
  }

  /*  TODO move to params. */
  /*  We are not going to feed noize inside filter :) */
  /*  Evolution step */
  for (i = 0; i < 5; i++) {
    J_u[i] = 0.0F;
  }

  get_prediction(X, u, J_u, p, dt, b_X, J_x, b_J_u, J_n);
  for (i = 0; i < 5; i++) {
    for (i0 = 0; i0 < 5; i0++) {
      b_J_x[i + 5 * i0] = 0.0F;
      b_J_n[i + 5 * i0] = 0.0F;
      for (i1 = 0; i1 < 5; i1++) {
        b_J_x[i + 5 * i0] += J_x[i + 5 * i1] * P[i1 + 5 * i0];
        b_J_n[i + 5 * i0] += (float)J_n[i + 5 * i1] * f_p->Q[i1 + 5 * i0];
      }
    }

    for (i0 = 0; i0 < 5; i0++) {
      c_J_x[i + 5 * i0] = 0.0F;
      c_J_n[i + 5 * i0] = 0.0F;
      for (i1 = 0; i1 < 5; i1++) {
        c_J_x[i + 5 * i0] += b_J_x[i + 5 * i1] * J_x[i0 + 5 * i1];
        c_J_n[i + 5 * i0] += b_J_n[i + 5 * i1] * (float)J_n[i0 + 5 * i1];
      }
    }
  }

  for (i = 0; i < 5; i++) {
    for (i0 = 0; i0 < 5; i0++) {
      P[i + 5 * i0] = (c_J_x[i + 5 * i0] + c_J_n[i + 5 * i0]) + b_J_u[i] *
        f_p->U * b_J_u[i0];
    }
  }

  for (i = 0; i < 5; i++) {
    for (i0 = 0; i0 < 5; i0++) {
      J_x[i0 + 5 * i] = (P[i0 + 5 * i] + P[i + 5 * i0]) / 2.0F;
    }
  }

  /*  Ensure it is symetric. On target I would store it as a triangle. */
  /*  Get predicted measurements */
  /* GET_II_MEASUREMENT */
  /*     [Y_II,J_Y_X,J_Y_U,J_Y_N] = GET_II_MEASUREMENT(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     30-Jul-2018 16:43:28 */
  b_J_u[0] = 0.0F;
  b_J_u[1] = -p[0] / b_X[4];
  b_J_u[2] = 0.0F;
  b_J_u[3] = 0.0F;
  b_J_u[4] = -1.0F / (b_X[4] * b_X[4]) * (u - p[0] * b_X[1]);
  z = y[0] - (u - p[0] * b_X[1]) / b_X[4];
  f0 = 0.0F;
  for (i = 0; i < 5; i++) {
    J_u[i] = 0.0F;
    for (i0 = 0; i0 < 5; i0++) {
      P[i0 + 5 * i] = J_x[i0 + 5 * i];
      J_u[i] += b_J_u[i0] * P[i0 + 5 * i];
    }

    f0 += J_u[i] * b_J_u[i];
  }

  Zinv = 1.0F / (f0 + f_p->R[0]);
  if ((double)(z * Zinv * z) < MahDistSquaredMax[0]) {
    for (i = 0; i < 5; i++) {
      J_u[i] = 0.0F;
      for (i0 = 0; i0 < 5; i0++) {
        J_u[i] += P[i + 5 * i0] * b_J_u[i0];
      }

      K[i] = J_u[i] * Zinv;
      for (i0 = 0; i0 < 5; i0++) {
        b_J_x[i + 5 * i0] = K[i] * b_J_u[i0];
      }

      for (i0 = 0; i0 < 5; i0++) {
        f0 = 0.0F;
        for (i1 = 0; i1 < 5; i1++) {
          f0 += b_J_x[i + 5 * i1] * P[i1 + 5 * i0];
        }

        J_x[i + 5 * i0] = P[i + 5 * i0] - f0;
      }

      b_X[i] += K[i] * z;
    }

    for (i = 0; i < 5; i++) {
      for (i0 = 0; i0 < 5; i0++) {
        P[i0 + 5 * i] = J_x[i0 + 5 * i];
      }
    }
  }

  /*  Get predicted measurements */
  /* GET_R_E_MEASUREMENT */
  /*     [Y_R_E,J_Y_X,J_Y_U,J_Y_N] = GET_R_E_MEASUREMENT(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     30-Jul-2018 16:43:28 */
  z = y[1] - b_X[4];
  f0 = 0.0F;
  for (i = 0; i < 5; i++) {
    J_u[i] = 0.0F;
    for (i0 = 0; i0 < 5; i0++) {
      J_u[i] += (float)iv1[i0] * P[i0 + 5 * i];
    }

    f0 += J_u[i] * (float)iv0[i];
  }

  Zinv = 1.0F / (f0 + f_p->R[1]);
  if ((double)(z * Zinv * z) < MahDistSquaredMax[1]) {
    for (i = 0; i < 5; i++) {
      J_u[i] = 0.0F;
      for (i0 = 0; i0 < 5; i0++) {
        J_u[i] += P[i + 5 * i0] * (float)iv0[i0];
      }

      K[i] = J_u[i] * Zinv;
      for (i0 = 0; i0 < 5; i0++) {
        b_J_x[i + 5 * i0] = K[i] * (float)iv1[i0];
      }

      for (i0 = 0; i0 < 5; i0++) {
        f0 = 0.0F;
        for (i1 = 0; i1 < 5; i1++) {
          f0 += b_J_x[i + 5 * i1] * P[i1 + 5 * i0];
        }

        J_x[i + 5 * i0] = P[i + 5 * i0] - f0;
      }

      b_X[i] += K[i] * z;
    }

    for (i = 0; i < 5; i++) {
      for (i0 = 0; i0 < 5; i0++) {
        P[i0 + 5 * i] = J_x[i0 + 5 * i];
      }
    }
  }

  /*  Update filter state */
  for (i = 0; i < 5; i++) {
    X[i] = b_X[i];
    X_out[i] = X[i];
    P_diag[i] = P[i * 6];
  }
}

/*
 * Arguments    : void
 * Return Type  : void
 */
void get_ekf_initialize(void)
{
  X_not_empty = false;
  get_prediction_init();
}

/*
 * Arguments    : void
 * Return Type  : void
 */
void get_ekf_terminate(void)
{
  /* (no terminate code required) */
}

/*
 * GET_II_MEASUREMENT
 *     [Y_II,J_Y_X,J_Y_U,J_Y_N] = GET_II_MEASUREMENT(IN1,V,IN3,IN4)
 * Arguments    : const float b_X[5]
 *                float v
 *                const float n[5]
 *                const float p[2]
 *                float *y_ii
 *                float J_y_x[5]
 *                float *J_y_u
 *                double J_y_n[5]
 * Return Type  : void
 */
void get_ii_measurement(const float b_X[5], float v, const float n[5], const
  float p[2], float *y_ii, float J_y_x[5], float *J_y_u, double J_y_n[5])
{
  int i5;
  (void)n;

  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     30-Jul-2018 16:43:28 */
  *y_ii = (v - p[0] * b_X[1]) / b_X[4];
  J_y_x[0] = 0.0F;
  J_y_x[1] = -p[0] / b_X[4];
  J_y_x[2] = 0.0F;
  J_y_x[3] = 0.0F;
  J_y_x[4] = -1.0F / (b_X[4] * b_X[4]) * (v - p[0] * b_X[1]);
  *J_y_u = 1.0F / b_X[4];
  for (i5 = 0; i5 < 5; i5++) {
    J_y_n[i5] = 0.0;
  }
}

/*
 * Arguments    : const float b_X[5]
 *                float u
 *                float b_ut
 *                const float n[5]
 *                const float p[2]
 *                float dt
 *                float X_out[5]
 *                float dX[5]
 *                float *utt
 * Return Type  : void
 */
void get_model_step(const float b_X[5], float u, float b_ut, const float n[5],
                    const float p[2], float dt, float X_out[5], float dX[5],
                    float *utt)
{
  float k1[5];
  float y;
  int i;
  float c_X[5];
  float k2[5];
  float k3[5];

  /* GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL */
  /*     [DX,DEBUG] = GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     30-Jul-2018 16:43:25 */
  k1[0] = b_X[1];
  k1[1] = -((b_X[3] * b_X[0] + b_X[2] * b_X[1]) - p[0] * (b_ut - p[0] * b_X[1]) /
            b_X[4]) / p[1];
  k1[2] = 0.0F;
  k1[3] = 0.0F;
  k1[4] = 0.0F;
  y = dt / 2.0F;
  for (i = 0; i < 5; i++) {
    c_X[i] = b_X[i] + y * k1[i];
  }

  /* GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL */
  /*     [DX,DEBUG] = GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     30-Jul-2018 16:43:25 */
  k2[0] = c_X[1];
  k2[1] = -((c_X[3] * c_X[0] + c_X[2] * c_X[1]) - p[0] * (b_ut - p[0] * c_X[1]) /
            c_X[4]) / p[1];
  k2[2] = 0.0F;
  k2[3] = 0.0F;
  k2[4] = 0.0F;
  y = dt / 2.0F;
  for (i = 0; i < 5; i++) {
    c_X[i] = b_X[i] + y * k2[i];
  }

  /* GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL */
  /*     [DX,DEBUG] = GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     30-Jul-2018 16:43:25 */
  k3[0] = c_X[1];
  k3[1] = -((c_X[3] * c_X[0] + c_X[2] * c_X[1]) - p[0] * (b_ut - p[0] * c_X[1]) /
            c_X[4]) / p[1];
  k3[2] = 0.0F;
  k3[3] = 0.0F;
  k3[4] = 0.0F;
  for (i = 0; i < 5; i++) {
    c_X[i] = b_X[i] + dt * k3[i];
  }

  /* GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL */
  /*     [DX,DEBUG] = GET_SYMGEN_STEP_LOUD_SPEAKER_IDENTIFICATION_FULL(IN1,V,IN3,IN4) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.0. */
  /*     30-Jul-2018 16:43:25 */
  y = dt / 6.0F;
  dX[0] = y * (((b_X[1] + 2.0F * k2[0]) + 2.0F * k3[0]) + c_X[1]);
  dX[1] = y * (((k1[1] + 2.0F * k2[1]) + 2.0F * k3[1]) + -((c_X[3] * c_X[0] +
    c_X[2] * c_X[1]) - p[0] * (u - p[0] * c_X[1]) / c_X[4]) / p[1]);
  dX[2] = 0.0F;
  dX[3] = 0.0F;
  dX[4] = 0.0F;
  for (i = 0; i < 5; i++) {
    X_out[i] = (b_X[i] + dX[i]) + n[i];
    dX[i] /= dt;
  }

  *utt = u;
}

/*
 * Arguments    : parameters_t *out
 * Return Type  : void
 */
void parameters_initializer(parameters_t *out)
{
  out->Bl = 0.23F;
  out->M_m = 8.0E-6F;
}

/*
 * Arguments    : char out[25]
 * Return Type  : void
 */
void state_names_initializer(char out[25])
{
  int i6;
  static const char cv0[25] = { 'x', 'd', ',', ' ', 'x', 'd', '_', 'd', 'o', 't',
    ',', ' ', 'R', '_', 'm', ',', ' ', 'K', '_', 'm', ',', ' ', 'R', '_', 'e' };

  for (i6 = 0; i6 < 25; i6++) {
    out[i6] = cv0[i6];
  }
}

/*
 * Arguments    : state_t *out
 * Return Type  : void
 */
void state_struct_initializer(state_t *out)
{
  out->xd = 0.0F;
  out->xd_dot = 0.0F;
  out->R_m = 0.009F;
  out->K_m = 41.75F;
  out->R_e = 31.75F;
}

/*
 * File trailer for get_ekf.c
 *
 * [EOF]
 */
